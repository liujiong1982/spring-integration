[[jpa]]
= JPA Support

Spring Integration's JPA (Java Persistence API) module provides components for performing various database operations using JPA. The following components are provided:

*<<jpa-inbound-channel-adapter,Inbound Channel Adapter>>*

		
*<<jpa-outbound-channel-adapter,Outbound Channel Adapter>>*

		
*<<jpa-updating-outbound-gateway,Updating Outbound Gateway>>*

		
*<<jpa-retrieving-outbound-gateway,Retrieving Outbound Gateway>>*

	

These components can be used to perform *select*, *create*, *update* and *delete* operations on the targeted databases by sending/receiving messages to them.

The JPA *Inbound Channel Adapter* lets you poll and retrieve (select) data from the database using JPA whereas the JPA *Outbound Channel Adapter* lets you create, update and delete entities.

Outbound Gateways for JPA can be used to persist entities to the database, yet allowing you to continue with the flow and execute further components downstream. Similarly, you can use an Outbound Gateway to retrieve entities from the database.

For example, you may use the Outbound Gateway, which receives a Message with a user Id as payload on its request channel, to query the database and retrieve the User entity and pass it downstream for further processing.

Recognizing these semantic differences, Spring Integration provides 2 separate JPA Outbound Gateways:

*Retrieving Outbound Gateway*

		
*Updating Outbound Gateway*

	

*Functionality*

All JPA components perform their respective JPA operations by using either one of the following:

*Entity classes*

		
*
					Java Persistence Query Language (JPQL) for update, select and
					delete (inserts are not supported by JPQL)
				*

		
*Native Query*

		
*Named Query*

	

In the following sections we will describe each of these components in more detail.

[[jpa-supported-persistence-providers]]
== Supported Persistence Providers

The Spring Integration JPA support has been tested using the following persistence providers:

*Hibernate*

			
*OpenJPA*

			
*EclipseLink*

		

When using a persistence provider, please ensure that the provider is compatible with JPA 2.0.

[[jpa-java-implementation]]
== Java Implementation

Each of the provided components will use the `o.s.i.jpa.core.JpaExecutor` class which in turn will use an implementation of the `o.s.i.jpa.core.JpaOperations` interface. `JpaOperations` operates like a typical Data Access Object (DAO) and provides methods such as *find*, *persist*, *executeUpdate* etc. For most use cases the provided default implementation `o.s.i.jpa.core.DefaultJpaOperations` should be sufficient. Nevertheless, you have the option to optionally specify your own implementation in case you require custom behavior.

For initializing a `JpaExecutor` you have to use one of 3 available constructors that accept one of:

*EntityManagerFactory*

			
*EntityManager* or

			
*JpaOperations*

		

NOTE: The XML Namespace Support described further below is also very flexible and provides configuration attributes for each JPA component to pass in an *EntityManagerFactory*, *EntityManager* or *JpaOperations* reference.

*Java Configuration Example*

The following example of a JPA *Retrieving Outbound Gateway* is configured purely through Java. In typical usage scenarios you will most likely prefer the XML Namespace Support described further below. However, the example illustrates how the classes are wired up. Understanding the inner workings can also be very helpful for debugging or customizing the individual JPA components.

First, we instantiate a `JpaExecutor` using an `EntityManager` as constructor argument. The `JpaExecutor` is then in return used as constructor argument for the `o.s.i.jpa.outbound.JpaOutboundGateway` and the `JpaOutboundGateway` will be passed as constructor argument into the `EventDrivenConsumer`.

[source,xml]
----
<bean id="jpaExecutor" class="o.s.i.jpa.core.JpaExecutor">
    <constructor-arg name="entityManager" ref="entityManager"/>
    <property name="entityClass"        value="o.s.i.jpa.test.entity.StudentDomain"/>
    <property name="jpaQuery"           value="select s from Student s where s.id = :id"/>
    <property name="expectSingleResult" value="true"/>
    <property name="jpaParameters" >
        <util:list>
            <bean class="org.springframework.integration.jpa.support.JpaParameter">
                <property name="name"       value="id"/>
                <property name="expression" value="payload"/>
            </bean>
        </util:list>
    </property>
</bean>

<bean id="jpaOutboundGateway" class="o.s.i.jpa.outbound.JpaOutboundGateway">
    <constructor-arg ref="jpaExecutor"/>
    <property        name="gatewayType"   value="RETRIEVING"/>
    <property        name="outputChannel" ref="studentReplyChannel"/>
</bean>

<bean id="getStudentEndpoint"
      class="org.springframework.integration.endpoint.EventDrivenConsumer">
    <constructor-arg name="inputChannel" ref="getStudentChannel"/>
    <constructor-arg name="handler"      ref="jpaOutboundGateway"/>
</bean>
----

NOTE: For more examples of constructing JPA components purely through Java, see the JUnit test-cases for the JPA Adapters.

[[jpa-namespace-support]]
== Namespace Support

When using XML namespace support, the underlying parser classes will instantiate the relevant Java classes for you. Thus, you typically don't have to deal with the inner workings of the JPA adapter. This section will document the XML Namespace Support provided by the Spring Integration and will show you how to use the XML Namespace Support to configure the Jpa components.

[[jpa-namespace-support-common-attributes]]
=== Common XML Namespace Configuration Attributes

Certain configuration parameters are shared amongst all JPA components and are described below:

*auto-startup*

Lifecycle attribute signaling if this component should be started during Application Context startup. Defaults to `true`. *Optional*.

*id*

Identifies the underlying Spring bean definition, which is an instance of either `EventDrivenConsumer` or `PollingConsumer`. *Optional*.

*entity-manager-factory*

The reference to the JPA Entity Manager Factory that will be used by the adapter to create the `EntityManager`. Either this attribute or the *entity-manager* attribute or the *jpa-operations* attribute must be provided.

*entity-manager*

The reference to the JPA Entity Manager that will be used by the component. Either this attribute or the *enity-manager-factory* attribute or the *jpa-operations* attribute must be provided.

NOTE: Usually your Spring Application Context only defines a JPA Entity Manager Factory and the EntityManager is injected using the @PersistenceContext annotation. This, however, is not applicable for the Spring Integration JPA components. Usually, injecting the JPA Entity Manager Factory will be best but in case you want to inject an EntityManager explicitly, you have to define a `SharedEntityManagerBean`. For more information, please see the relevant http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/orm/jpa/support/SharedEntityManagerBean.html[JavaDoc].

[source,xml]
----
<bean id="entityManager"
      class="org.springframework.orm.jpa.support.SharedEntityManagerBean">
    <property name="entityManagerFactory" ref="entityManagerFactoryBean" />
</bean>
----

*jpa-operations*

Reference to a bean implementing the `JpaOperations` interface. In rare cases it might be advisable to provide your own implementation of the `JpaOperations` interface, instead of relying on the default implementation `org.springframework.integration.jpa.core.DefaultJpaOperations`. As `JpaOperations` wraps the necessary datasource; the JPA Entity Manager or JPA Entity Manager Factory must not be provided, if the *jpa-operations* attribute is used.

*entity-class*

The fully qualified name of the entity class. The exact semantics of this attribute vary, depending on whether we are performing a persist/update operation or whether we are retrieving objects from the database.

When retrieving data, you can specify the *entity-class* attribute to indicate that you would like to retrieve objects of this type from the database. In that case you must not define any of the query attributes ( *jpa-query*, *native-query* or *named-query* )

When persisting data, the *entity-class* attribute will indicate the type of object to persist. If not specified (for persist operations) the entity class will be automatically retrieved from the Message's payload.

*jpa-query*

Defines the JPA query (Java Persistence Query Language) to be used.

*native-query*

Defines the native SQL query to be used.

*named-query*

This attribute refers to a named query. A named query can either be defined in Native SQL or JPAQL but the underlying JPA persistence provider handles that distinction internally.

[[jpa-parameters]]
=== Providing JPA Query Parameters

For providing parameters, the *parameter* XML sub-element can be used. It provides a mechanism to provide parameters for the queries that are either based on the Java Persistence Query Language (JPQL) or native SQL queries. Parameters can also be provided for Named Queries.

*Expression based Parameters*

[source,xml]
----
<int-jpa:parameter expression="payload.name" name="firstName"/>
----

*Value based Parameters*

[source,xml]
----
<int-jpa:parameter name="name" type="java.lang.String" value="myName"/>
----

*Positional Parameters*

[source,xml]
----
<int-jpa:parameter expression="payload.name"/>
<int-jpa:parameter type="java.lang.Integer" value="21"/>
----

[[jpa-transactions]]
=== Transaction Handling

All JPA operations like Insert, Update and Delete require a transaction to be active whenever they are performed. For Inbound Channel Adapters there is nothing special to be done, it is similar to the way we configure transaction managers with pollers used with other inbound channel adapters.The xml snippet below shows a sample where a transaction manager is configured with the poller used with an *Inbound Channel Adapter*.

[source,xml]
----
<int-jpa:inbound-channel-adapter
    channel="inboundChannelAdapterOne"
    entity-manager="em"
    auto-startup="true"
    jpa-query="select s from Student s"
    expect-single-result="true"
    delete-after-poll="true">
    <int:poller fixed-rate="2000" >
        <int:transactional propagation="REQUIRED"
            transaction-manager="transactionManager"/>
    </int:poller>
</int-jpa:inbound-channel-adapter>
----

However, it may be necessary to specifically start a transaction when using an *Outbound Channel Adapter*/*Gateway*. If a *DirectChannel* is an input channel for the outbound adapter/gateway, and if transaction is active in the current thread of execution, the JPA operation will be performed in the same transaction context. We can also configure to execute this JPA operation in a new transaction as below.

[source,xml]
----
<int-jpa:outbound-gateway
    request-channel="namedQueryRequestChannel"
    reply-channel="namedQueryResponseChannel"
    named-query="updateStudentByRollNumber"
    entity-manager="em"
    gateway-type="UPDATING">
    <int-jpa:parameter name="lastName" expression="payload"/>
    <int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/>
		Bold Section qName:emphasis level:5, chunks:[
		,     <int-jpa:transactional propagation="REQUIRES_NEW"
        transaction-manager="transactionManager"/>, 
		] attrs:[role:bold]
</int-jpa:outbound-gateway>
----

As we can see above, the *transactional* sub element of the outbound gateway/adapter will be used to specify the transaction attributes. It is optional to define this child element if you have *DirectChannel* as an input channel to the adapter and you want the adapter to execute the operations in the same transaction context as the caller. If, however, you are using an *ExecutorChannel*, it is required to have the *transactional* sub element as the invoking client's transaction context is not propagated.

NOTE: Unlike the *transactional* sub element of the poller which is defined in the spring integration's namespace, the *transactional* sub element for the outbound gateway/adapter is defined in the jpa namespace.

[[jpa-inbound-channel-adapter]]
== Inbound Channel Adapter

An *Inbound Channel Adapter* is used to execute a *select* query over the database using JPA QL and return the result. The message payload will be either a single entity or a `List` of entities. Below is a sample xml snippet that shows a sample usage of *inbound-channel-adapter*.

[source,xml]
----
<int-jpa:inbound-channel-adapter channel="inboundChannelAdapterOne" TBD Section qName:co level:4, chunks:[] attrs:[id:inboundAdapterChannel]
                    entity-manager="em" TBD Section qName:co level:4, chunks:[] attrs:[id:inboundAdapterEntityManager]
                    auto-startup="true" TBD Section qName:co level:4, chunks:[] attrs:[id:inboundAdapterAutoStartup]
                    query="select s from Student s" TBD Section qName:co level:4, chunks:[] attrs:[id:inboundAdapterQuery]
                    expect-single-result="true" TBD Section qName:co level:4, chunks:[] attrs:[id:inboundAdapterExpectResult]
                    max-number-of-results="" TBD Section qName:co level:4, chunks:[] attrs:[id:inboundAdapterMaxResults]
                    max-results="" TBD Section qName:co level:4, chunks:[] attrs:[id:inboundAdapterMaxResults2]
                    max-results-expression="" TBD Section qName:co level:4, chunks:[] attrs:[id:inboundAdapterMaxResultsExpression]
                    delete-after-poll="true" TBD Section qName:co level:4, chunks:[] attrs:[id:inboundAdapterDeleteAfterPoll]
                    flush-after-delete="true"> TBD Section qName:co level:4, chunks:[] attrs:[id:inboundAdapterFlushAfterDelete]
    <int:poller fixed-rate="2000" >
      <int:transactional propagation="REQUIRED" transaction-manager="transactionManager"/>
    </int:poller>
</int-jpa:inbound-channel-adapter>
			
----

TBD Section qName:calloutlist level:3, chunks:[
                 , TBD Section qName:callout level:4, chunks:[
                     , Paragraph: chunks:[
                         The channel over which the , Bold Section qName:emphasis level:6, chunks:[inbound-channel-adapter] attrs:[:],  will put the
                         messages with the payload received after executing the provided JPA QL in the, 
                         , Bold Section qName:emphasis level:6, chunks:[query] attrs:[:],  attribute.
                     ], 
                 ] attrs:[arearefs:inboundAdapterChannel], 
                 , TBD Section qName:callout level:4, chunks:[
                     , Paragraph: chunks:[
                         The , Monospaced ([EntityManager]),  instance that will be used to perform the
                         required JPA operations., 
                     ], 
                 ] attrs:[arearefs:inboundAdapterEntityManager], 
                 , TBD Section qName:callout level:4, chunks:[
                     , Paragraph: chunks:[
                         Attribute signalling if the component should be automatically started on startup of
                         the Application Context. The value defaults to , Monospaced ([true]), 
                     ], 
                 ] attrs:[arearefs:inboundAdapterAutoStartup], 
                 , TBD Section qName:callout level:4, chunks:[
                     , Paragraph: chunks:[
                         The JPA QL that needs to be executed and whose result needs to be sent out as the
                         payload of the message, 
                     ], 
                 ] attrs:[arearefs:inboundAdapterQuery], 
                 , TBD Section qName:callout level:4, chunks:[
                     , Paragraph: chunks:[
                         The attribute that tells if the executed JPQL query gives a single entity in the result
                         or a , Monospaced ([List]),  of entities. If the value is set to , Monospaced ([true]), ,
                         the single entity retrieved is sent as the payload of the message. If, however, multiple, 
                         results are returned after setting this to , Monospaced ([true]), , a
                         , Monospaced ([MessagingException]),  is thrown. The value defaults to , Monospaced ([false]), .
                     ], 
                 ] attrs:[arearefs:inboundAdapterExpectResult], 
                 , TBD Section qName:callout level:4, chunks:[
					, Paragraph: chunks:[
						, Bold Section qName:emphasis level:6, chunks:[Deprecated] attrs:[:], . Use , Monospaced ([max-results]),  instead.
						, Bold Section qName:emphasis level:6, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inboundAdapterMaxResults], 
				, TBD Section qName:callout level:4, chunks:[
					, Paragraph: chunks:[
						This non zero, non negative integer value tells the adapter not to select more than given number
						of rows on execution of the select operation. By default, if this attribute is not set,, 
						all the possible records are selected by given query. This attribute is mutually exclusive with
						, Monospaced ([max-results-expression]), . , Bold Section qName:emphasis level:6, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inboundAdapterMaxResults2], 
				, TBD Section qName:callout level:4, chunks:[
					, Paragraph: chunks:[
						An expression, mutually exclusive with , Monospaced ([max-results]), , that can
						be used to provide an expression that will be evaluated to find the maximum number of results, 
						in a result set. , Bold Section qName:emphasis level:6, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inboundAdapterMaxResultsExpression], 
                 , TBD Section qName:callout level:4, chunks:[
                     , Paragraph: chunks:[
                         Set this value to , Monospaced ([true]),  if you want
                         to delete the rows received after execution of the query., 
                         Please ensure that the component is operating as part
                         of a transaction., 

                         Otherwise, you may encounter an Exception such as:
                         , Bold Section qName:emphasis level:6, chunks:[java.lang.IllegalArgumentException: Removing
                         a detached instance ...] attrs:[:], 
                     ], 
                 ] attrs:[arearefs:inboundAdapterDeleteAfterPoll], 
				 , TBD Section qName:callout level:4, chunks:[
                     , Paragraph: chunks:[
                         Set this value to , Monospaced ([true]),  if you want
                         to the persistence context immediately after deleting received entities, 
						 and if you don't want rely on the, Monospaced ([EntityManager]), 's flushMode.
						 The default value is set to , Monospaced ([false]), .
                     ], 
                 ] attrs:[arearefs:inboundAdapterFlushAfterDelete], 
		] attrs:[:][[jpaInboundChannelAdapterParameters]]
=== Configuration Parameter Reference

[source,xml]
----
<int-jpa:inbound-channel-adapter
  auto-startup="true" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptAutoStart]
  channel="" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptChannel]
  delete-after-poll="false"  TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptDelAftPoll]
  delete-per-row="false"  TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptDelPerRow]
  entity-class=""  TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptEntityClass]
  entity-manager="" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptEntityMgr]
  entity-manager-factory="" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptEntityMgrFact]
  expect-single-result="false" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptExpectSingleResult]
  id=""
  jpa-operations="" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptJpaOperation]
  jpa-query="" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptJpaQuery]
  named-query="" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptNamedQuery]
  native-query="" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptNativeQuery]
  parameter-source="" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptParamSource]
  send-timeout="" TBD Section qName:co level:5, chunks:[] attrs:[id:inAdaptSendTimeout]>
  <int:poller ref="myPoller"/>
 </int-jpa:inbound-channel-adapter>
----

TBD Section qName:calloutlist level:4, chunks:[
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						This , Bold Section qName:emphasis level:7, chunks:[Lifecycle] attrs:[:],  attribute signaled if this component should be started during startup of the Application Context.
						This attribute defaults to true., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptAutoStart], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The channel to which the adapter will send a message with the payload that was received after
						performing the , desired JPA operation.
					], 
				] attrs:[arearefs:inAdaptChannel], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						A boolean flag that indicates whether the records selected are to be deleted
						after they are being polled by the adapter. By default the value is , Monospaced ([false]), ,
						that is, the records will not be deleted. Please ensure that the component is operating as part of a transaction., 
						Otherwise, you may encounter an Exception such as:
						, Bold Section qName:emphasis level:7, chunks:[java.lang.IllegalArgumentException: Removing a detached instance ...] attrs:[:], ., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptDelAftPoll], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						A boolean flag that indicates whether the records can be deleted in bulk or are deleted
						one record at a time. By default the value is , Monospaced ([false]), , that is, the records are bulk deleted., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptDelPerRow], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The fully qualified name of the entity class that would be queried from the database. The adapter will automatically
						build a JPA Query to be executed based on the entity class name provided., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptEntityClass], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						An instance of , Monospaced ([javax.persistence.EntityManager]),  that will be used to perform the JPA operations. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptEntityMgr], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						An instance of , Monospaced ([javax.persistence.EntityManagerFactory]),  that will be used to obtain
						an instance of , Monospaced ([javax.persistence.EntityManager]),  that will perform the JPA operations. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptEntityMgrFact], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						A boolean flag indicating whether the select operation is expected to return a single result or a , Monospaced ([List]),  of results.
						If this flag is set to , Monospaced ([true]), , the single entity selected is sent as the payload
						of the message. If multiple entities are returned, an exception is thrown., 
						If , Monospaced ([false]), , the , Monospaced ([List]),  of entities is being sent as the payload of the message.
						By default the value is , Monospaced ([false]), ., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptExpectSingleResult], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						An implementation of , Monospaced ([org.springframework.integration.jpa.core.JpaOperations]),  that would be used to perform the JPA operations.
						It is recommended not to provide an implementation of your own but use the default, 
						, Monospaced ([org.springframework.integration.jpa.core.DefaultJpaOperations]),  implementation. Either of the
						, Bold Section qName:emphasis level:7, chunks:[entity-manager] attrs:[:], , , Bold Section qName:emphasis level:7, chunks:[entity-manager-factory] attrs:[:],  or
						, Bold Section qName:emphasis level:7, chunks:[jpa-operations] attrs:[:],  attributes is to be used. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptJpaOperation], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The JPA QL that needs to be executed by this adapter., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptJpaQuery], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The named query that needs to be executed by this adapter., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptNamedQuery], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The native query that will be executed by this adapter. Either of the , Bold Section qName:emphasis level:7, chunks:[jpa-query] attrs:[:], ,
						, Bold Section qName:emphasis level:7, chunks:[named-query] attrs:[:], ,, Bold Section qName:emphasis level:7, chunks:[entity-class] attrs:[:],  or , Bold Section qName:emphasis level:7, chunks:[native-query] attrs:[:], 
						attributes are to be used. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptNativeQuery], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						An implementation of , Monospaced ([o.s.i.jpa.support.parametersource.ParameterSource]), 
						which will be used to resolve the values of the parameters provided in the query. Ignored if , Bold Section qName:emphasis level:7, chunks:[entity-class] attrs:[:], 
						attribute is provided., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptParamSource], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						Maximum amount of time in milliseconds to wait when sending a message to the channel., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:inAdaptSendTimeout], 
			] attrs:[:][[jpa-outbound-channel-adapter]]
== Outbound Channel Adapter

The JPA Outbound channel adapter allows you to accept messages over a request channel. The payload can either be used as the entity to be persisted, or used along with the headers in parameter expressions for a defined JPQL query to be executed. In the following sub sections we shall see what those possible ways of performing these operations are.

=== Using an Entity Class

The XML snippet below shows how we can use the Outbound Channel Adapter to persist an entity to the database.

[source,xml]
----
<int-jpa:outbound-channel-adapter channel="entityTypeChannel" TBD Section qName:co level:5, chunks:[] attrs:[id:entityTypeChannel]
    entity-class="org.springframework.integration.jpa.test.entity.Student" TBD Section qName:co level:5, chunks:[] attrs:[id:entityClass]
    persist-mode="PERSIST" TBD Section qName:co level:5, chunks:[] attrs:[id:persistMode]
    entity-manager="em"/ >TBD Section qName:co level:5, chunks:[] attrs:[id:entityMgr]
----

TBD Section qName:calloutlist level:4, chunks:[
					, TBD Section qName:callout level:5, chunks:[
						, Paragraph: chunks:[
							The channel over which a valid JPA entity will be
							sent to the JPA Outbound Channel Adapter., 
						], 
					] attrs:[arearefs:entityTypeChannel], 
					, TBD Section qName:callout level:5, chunks:[
						, Paragraph: chunks:[
							The fully qualified name of the entity class that
							would be accepted by the adapter to be persisted, 
							in the database. You can actually leave off this
							attribute in most cases as the adapter can determine, 
							the entity class automatically from the Spring Integration
							Message payload., 
						], 
					] attrs:[arearefs:entityClass], 
					, TBD Section qName:callout level:5, chunks:[
						, Paragraph: chunks:[
							The operation that needs to be done by the adapter, valid values are
							, Bold Section qName:emphasis level:7, chunks:[PERSIST] attrs:[:], , , Bold Section qName:emphasis level:7, chunks:[MERGE] attrs:[:], 
							and , Bold Section qName:emphasis level:7, chunks:[DELETE] attrs:[:], . The default value
							is , Bold Section qName:emphasis level:7, chunks:[MERGE] attrs:[:], .
						], 
					] attrs:[arearefs:persistMode], 
					, TBD Section qName:callout level:5, chunks:[
						, Paragraph: chunks:[
							The JPA entity manager to be used.
						], 
					] attrs:[arearefs:entityMgr], 
				] attrs:[:]As we can see above these 4 attributes of the *outbound-channel-adapter* are all we need to configure it to accept entities over the input channel and process them to *PERSIST*,*MERGE* or *DELETE* it from the underlying data source.

NOTE: As of *Spring Integration 3.0*, payloads to *persist* or *merge* can also be of type http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html[java.lang.Iterable]. In that case, each object returned by the `Iterable` is treated as an entity and persisted or merged using the underlying `EntityManager`. *NULL* values returned by the iterator are ignored.

=== Using JPA Query Language (JPA QL)

We have seen in the above sub section how to perform a *PERSIST* action using an entity We will now see how to use the outbound channel adapter which uses JPA QL (Java Persistence API Query Language)

[source,xml]
----
<int-jpa:outbound-channel-adapter channel="jpaQlChannel" TBD Section qName:co level:5, chunks:[] attrs:[id:jpaQlInputChannel]
  jpa-query="update Student s set s.firstName = :firstName where s.rollNumber = :rollNumber" TBD Section qName:co level:5, chunks:[] attrs:[id:jpaQlQuery]
  entity-manager="em"> TBD Section qName:co level:5, chunks:[] attrs:[id:jpaQlEntityManager]
    <int-jpa:parameter name="firstName"  expression="payload['firstName']"/> TBD Section qName:co level:5, chunks:[] attrs:[id:jpaQlParam]
    <int-jpa:parameter name="rollNumber" expression="payload['rollNumber']"/>
</int-jpa:outbound-channel-adapter>
----

TBD Section qName:calloutlist level:4, chunks:[
                    , TBD Section qName:callout level:5, chunks:[
                        , Paragraph: chunks:[
                            The input channel over which the message is being sent to the outbound
                            channel adapter, 
                        ], 
                    ] attrs:[arearefs:jpaQlInputChannel], 
                    , TBD Section qName:callout level:5, chunks:[
                        , Paragraph: chunks:[
                            The JPA QL that needs to be executed.This query may contain parameters that will be evaluated
                            using the , Bold Section qName:emphasis level:7, chunks:[parameter] attrs:[:],  child tag.
                        ], 
                    ] attrs:[arearefs:jpaQlQuery], 
                    , TBD Section qName:callout level:5, chunks:[
                        , Paragraph: chunks:[
                            The entity manager used by the adapter to perform the JPA operations
                        ], 
                    ] attrs:[arearefs:jpaQlEntityManager], 
                    , TBD Section qName:callout level:5, chunks:[
                        , Paragraph: chunks:[
                            This sub element, one for each parameter will be used to evaluate the value of
                            the parameter names specified in the JPA QL specified in the , Bold Section qName:emphasis level:7, chunks:[query] attrs:[:],  attribute
                        ], 
                    ] attrs:[arearefs:jpaQlParam], 
				] attrs:[:]The *parameter* sub element accepts an attribute *name* which corresponds to the named parameter specified in the provided JPA QL (point 2 in the above mentioned sample). The value of the parameter can either be static or can be derived using an expression. The static value and the expression to derive the value is specified using the *value* and the *expression* attributes respectively. These attributes are mutually exclusive.

If the *value* attribute is specified we can provide an optional *type* attribute. The value of this attribute is the fully qualified name of the class whose value is represented by the *value* attribute. By default the type is assumed to be a `java.lang.String`.

[source,xml]
----
<int-jpa:outbound-channel-adapter ... >
    <int-jpa:parameter name="level" value="2" type="java.lang.Integer"/>
    <int-jpa:parameter name="name" expression="payload['name']"/>
</int-jpa:outbound-channel-adapter>
----

As seen in the above snippet, it is perfectly valid to use multiple *parameter* sub elements within an outbound channel adapter tag and derive some parameters using expressions and some with static value. However, care should be taken not to specify the same parameter name multiple times, and, provide one *parameter* sub element for each named parameter specified in the JPA query. For example, we are specifying two parameters *level* and *name* where *level* attribute is a static value of type `java.lang.Integer`, where as the *name* attribute is derived from the payload of the message

NOTE: Though specifying *select* is valid for JPA QL, it makes no sense as outbound channel adapters will not be returning any result. If you want to select some values, consider using the outbound gateway instead.

=== Using Native Queries

In this section we will see how to use native queries to perform the operations using JPA outbound channel adapter. Using native queries is similar to using JPA QL, except that the query specified here is a native database query. By choosing native queries we lose the database vendor independence which we get using JPA QL.

 One of the things we can achieve using native queries is to perform database inserts, which is not possible using JPA QL (To perform inserts we send JPA entities to the channel adapter as we have seen earlier). Below is a small xml fragment that demonstrates the use of native query to insert values in a table. Please note that we have only mentioned the important attributes below. All other attributes like *channel*, *entity-manager* and the *parameter* sub element has the same semantics as when we use JPA QL.

 IMPORTANT: Please be aware that named parameters may not be supported by your JPA provider in conjunction with native SQL queries. While they work fine using Hibernate, OpenJPA and EclipseLink do NOT support them: https://issues.apache.org/jira/browse/OPENJPA-111 Section 3.8.12 of the JPA 2.0 spec states: "Only positional parameter binding and positional access to result items may be portably used for native queries."

 [source,xml]
----
<int-jpa:outbound-channel-adapter channel="nativeQlChannel"
  native-query="insert into STUDENT_TABLE(FIRST_NAME,LAST_UPDATED) values (:lastName,:lastUpdated)" TBD Section qName:co level:6, chunks:[] attrs:[id:nativeOutboundAdapterNativeQuery]
  entity-manager="em">
    <int-jpa:parameter name="lastName" expression="payload['updatedLastName']"/>
    <int-jpa:parameter name="lastUpdated" expression="new java.util.Date()"/>
</int-jpa:outbound-channel-adapter>
----

 TBD Section qName:calloutlist level:5, chunks:[
                      , TBD Section qName:callout level:6, chunks:[
                          , Paragraph: chunks:[
                              The native query that will be executed by this outbound channel adapter
                          ], 
                      ] attrs:[arearefs:nativeOutboundAdapterNativeQuery], 
                  ] attrs:[:]

=== Using Named Queries

We will now see how to use named queries after seeing using entity, JPA QL and native query in previous sub sections. Using named query is also very similar to using JPA QL or a native query, except that we specify a named query instead of a query. Before we go further and see the xml fragment for the declaration of the *outbound-channel-adapter*, we will see how named JPA named queries are defined.

 In our case, if we have an entity called `Student`, then we have the following in the class to define two named queries *selectStudent* and *updateStudent*. Below is a way to define named queries using annotations

 [source,java]
----
@Entity
@Table(name="Student")
@NamedQueries({
    @NamedQuery(name="selectStudent",
        query="select s from Student s where s.lastName = 'Last One'"),
    @NamedQuery(name="updateStudent",
        query="update Student s set s.lastName = :lastName,
               lastUpdated = :lastUpdated where s.id in (select max(a.id) from Student a)")
})
public class Student {

...
----

 You can alternatively use the *orm.xml* to define named queries as seen below

 [source,xml]
----
<entity-mappings ...>
    ...
    <named-query name="selectStudent">
        <query>select s from Student s where s.lastName = 'Last One'</query>
    </named-query>
</entity-mappings>
----

 Now that we have seen how we can define named queries using annotations or using *orm.xml*, we will now see a small xml fragment for defining an *outbound-channel-adapter* using named query

 [source,xml]
----
<int-jpa:outbound-channel-adapter channel="namedQueryChannel"
            named-query="updateStudent"	TBD Section qName:co level:6, chunks:[] attrs:[id:namedQuery]
            entity-manager="em">
        <int-jpa:parameter name="lastName" expression="payload['updatedLastName']"/>
        <int-jpa:parameter name="lastUpdated" expression="new java.util.Date()"/>
</int-jpa:outbound-channel-adapter>
----

 TBD Section qName:calloutlist level:5, chunks:[
                    , TBD Section qName:callout level:6, chunks:[
                        , Paragraph: chunks:[
                            The named query that we want the adapter to execute when it receives a message over the channel
                        ], 
                    ] attrs:[arearefs:namedQuery], 
                ] attrs:[:]

[[jpaOutboundChannelAdapterParameters]]
=== Configuration Parameter Reference

[source,xml]
----
<int-jpa:outbound-channel-adapter
  auto-startup="true" TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptAutoStart]
  channel="" TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptChannel]
  entity-class="" TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptEntityClass]
  entity-manager="" TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptEntityManager]
  entity-manager-factory="" TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptEntityMgrFact]
  id=""
  jpa-operations="" TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptJpaOperation]
  jpa-query="" TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptJpaQuery]
  named-query="" TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptNamedQuery]
  native-query="" TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptNativeQuery]
  order="" TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptOrder]
  parameter-source-factory=""  TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptParamSourceFact]
  persist-mode="MERGE"  TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptPersistMode]
  flush="true"  TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptFlush]
  flush-size="10"  TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptFlushSize]
  clear-on-flush="true"  TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptclearOnFlash]
  use-payload-as-parameter-source="true"  TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptUserPayloadAsParamSrc]
	<int:poller/>
	<int-jpa:transactional/>   TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptTransactional]
	<int-jpa:parameter/>   TBD Section qName:co level:5, chunks:[] attrs:[id:outAdaptParam]
</int-jpa:outbound-channel-adapter>
----

TBD Section qName:calloutlist level:4, chunks:[
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						Lifecycle attribute signaling if this component should be started during Application Context startup. Defaults to , Monospaced ([true]), . , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptAutoStart], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The channel from which the outbound adapter will receive messages for performing the desired operation.
					], 
				] attrs:[arearefs:outAdaptChannel], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The fully qualified name of the entity class for the JPA
						Operation. The attributes , Bold Section qName:emphasis level:7, chunks:[entity-class] attrs:[:], ,
						, Bold Section qName:emphasis level:7, chunks:[query] attrs:[:],  and , Bold Section qName:emphasis level:7, chunks:[named-query] attrs:[:], 
						are mutually exclusive. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptEntityClass], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						An instance of , Monospaced ([javax.persistence.EntityManager]),  that will be used to perform the JPA operations. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptEntityManager], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						An instance of , Monospaced ([javax.persistence.EntityManagerFactory]),  that will be used to
						obtain an instance of , Monospaced ([javax.persistence.EntityManager]),  that will perform the JPA operations. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptEntityMgrFact], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						An implementation of , Monospaced ([org.springframework.integration.jpa.core.JpaOperations]),  that would be used to perform the JPA operations.
						It is recommended not to provide an implementation of your own but use the default, 
						, Monospaced ([org.springframework.integration.jpa.core.DefaultJpaOperations]),  implementation. Either of the
						, Bold Section qName:emphasis level:7, chunks:[entity-manager] attrs:[:], , , Bold Section qName:emphasis level:7, chunks:[entity-manager-factory] attrs:[:],  or
						, Bold Section qName:emphasis level:7, chunks:[jpa-operations] attrs:[:],  attributes is to be used. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptJpaOperation], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The JPA QL that needs to be executed by this adapter., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptJpaQuery], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The named query that needs to be executed by this adapter., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptNamedQuery], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The native query that will be executed by this adapter. Either of the , Bold Section qName:emphasis level:7, chunks:[jpa-query] attrs:[:], ,
						, Bold Section qName:emphasis level:7, chunks:[named-query] attrs:[:],  or , Bold Section qName:emphasis level:7, chunks:[native-query] attrs:[:],  attributes are to be used. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptNativeQuery], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The order for this consumer when multiple consumers are registered thereby
						managing load- balancing and/or failover. Optional (Defaults to , Bold Section qName:emphasis level:7, chunks:[Ordered.LOWEST_PRECEDENCE] attrs:[:], ).
					], 
				] attrs:[arearefs:outAdaptOrder], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						An instance of , Monospaced ([o.s.i.jpa.support.parametersource.ParameterSourceFactory]), 
						that will be used to get an instance of , Monospaced ([o.s.i.jpa.support.parametersource.ParameterSource]), 
						which will be used to resolve the values of the parameters provided in the query.
						Ignored if operations are performed using a JPA entity. If a parameter sub element is used, the factory must be of, 
						type , Monospaced ([ExpressionEvaluatingParameterSourceFactory]), 
						located in package , Monospaced ([o.s.i.jpa.support.parametersource]), . , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptParamSourceFact], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						Accepts one of the following: , Bold Section qName:emphasis level:7, chunks:[PERSIST] attrs:[:], ,
						, Bold Section qName:emphasis level:7, chunks:[MERGE] attrs:[:],  or , Bold Section qName:emphasis level:7, chunks:[DELETE] attrs:[:], .
						Indicates the operation that the adapter needs to perform., 
						Relevant only if an entity is being used for JPA operations.
						Ignored if JPA QL, named query or native query is provided. Defaults to , Bold Section qName:emphasis level:7, chunks:[MERGE] attrs:[:], . , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
					, Paragraph: chunks:[
						As of , Bold Section qName:emphasis level:7, chunks:[Spring Integration 3.0] attrs:[role:bold], ,
						payloads to , Bold Section qName:emphasis level:7, chunks:[persist] attrs:[:],  or
						, Bold Section qName:emphasis level:7, chunks:[merge] attrs:[:],  can also be of type
						, Monospaced ([http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html[java.lang.Iterable]]), .
						In that case, each object returned by the, 
						, Monospaced ([Iterable]),  is treated as
						an entity and persisted or merged using the underlying, 
						, Monospaced ([EntityManager]), .
						, Bold Section qName:emphasis level:7, chunks:[NULL] attrs:[:],  values returned by the iterator are ignored.
					], 
				] attrs:[arearefs:outAdaptPersistMode], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						Set this value to , Monospaced ([true]),  if you want
						to flush the persistence context immediately,  after persist, merge or delete operations
						and don't want to rely on the , Monospaced ([EntityManager]), 's flushMode.
						The default value is set to , Monospaced ([false]), . Applies only if the , Monospaced ([flush-size]), 
						attribute isn't specified. If this attribute is set to , Monospaced ([true]), ,
						then , Monospaced ([flush-size]),  will be implicitly set to , Monospaced ([1]), , if it wasn't configured to any other value.
					], 
				] attrs:[arearefs:outAdaptFlush], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						Set this attribute to a value greater than '0' if you want
						to flush the persistence context immediately after persist, merge or delete operations, 
						and don't want to rely on the , Monospaced ([EntityManager]), 's flushMode.
						The default value is set to , Monospaced ([0]),  which means 'no flush'.
						This attribute is geared towards messages with , Monospaced ([Iterable]),  payloads.
						For instance, if , Monospaced ([flush-size]),  is set to , Monospaced ([3]), ,
						then , Monospaced ([entityManager.flush()]),  is called after every third entity.
						Furthermore, , Monospaced ([entityManager.flush()]),  will be called once more after the entire loop.
						There is no reason to configure the , Monospaced ([flush]), 
						attribute, if the 'flush-size' attribute is specified with a value greater than '0'.
					], 
				] attrs:[arearefs:outAdaptFlushSize], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						Set this value to 'true' if you want
						to clear persistence context immediately after each flush operation., 
						The attribute's value is applied only if the , Monospaced ([flush]),  attribute is set to
						, Monospaced ([true]),  or if the , Monospaced ([flush-size]),  attribute is set to a value greater than , Monospaced ([0]), .
					], 
				] attrs:[arearefs:outAdaptclearOnFlash], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						If set to true, the payload of the Message will be used as a source for providing parameters.
						If false, however, the entire Message will be available as a source for parameters., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptUserPayloadAsParamSrc], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						Defines the transaction management attributes and the reference to transaction manager to be used by the JPA
						adapter., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptTransactional], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						One or more , Bold Section qName:emphasis level:7, chunks:[parameter] attrs:[:],  attributes, one for each parameter used in the query. The value or expression
						provided will be evaluated to compute the value of the parameter., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outAdaptParam], 
			] attrs:[:][[jpa-outbound-gateways]]
== Outbound Gateways

The JPA *Inbound Channel Adapter* allows you to poll a database in order to retrieve one or more JPA entities and the retrieved data is consequently used to start a Spring Integration flow using the retrieved data as message payload.

Additionally, you may use JPA *Outbound Channel Adapters* at the end of your flow in order to persist data, essentially terminating the flow at the end of the persistence operation.

However, how can you execute JPA persistence operation in the middle of a flow? For example, you may have business data that you are processing in your Spring Integration message flow, that you would like to persist, yet you still need to execute other components further downstream. Or instead of polling the database using a poller, you rather have the need to execute JPQL queries and retrieve data actively which then is used to being processed in subsequent components within your flow.

This is where JPA Outbound Gateways come into play. They give you the ability to persist data as well as retrieving data. To facilitate these uses, Spring Integration provides two types of JPA Outbound Gateways:

*Updating Outbound Gateway*

			
*Retrieving Outbound Gateway*

		

Whenever the Outbound Gateway is used to perform an action that saves, updates or soley deletes some records in the database, you need to use an *Updating Outbound Gateway* gateway. If for example an *entity* is used to persist it, then a merged/persisted entity is returned as a result. In other cases the number of records affected (updated or deleted) is returned instead.

When retrieving (selecting) data from the database, we use a *Retrieving Outbound Gateway*. With a *Retrieving Outbound Gateway* gateway, we can use either JPQL, Named Queries (native or JPQL-based) or Native Queries (SQL) for selecting the data and retrieving the results.

An *Updating Outbound Gateway* is functionally very similar to an *Outbound Channel Adapter*, except that an *Updating Outbound Gateway* is used to send a result to the Gateway's *reply channel* after performing the given JPA operation.

A *Retrieving Outbound Gateway* is quite similar to an *Inbound Channel Adapter*.

NOTE: We recommend you to first refer to the JPA Outbound Channel Adapter section and the JPA Inbound Channel Adapter sections above, as most of the common concepts are being explained there.

This similarity was the main factor to use the central `JpaExecutor` class to unify common functionality as much as possible.

Common for all JPA Outbound Gateways and simlar to the *outbound-channel-adapter*, we can use

*Entity classes*

			
*JPA Query Language (JPQL)*

			
*Native query*

			
*Named query*

		

for performing various JPA operations. For configuration examples please see <<outboundGatewaySamples>>.

[[jpa-outbound-gateway-common-parameters]]
=== Common Configuration Parameters

JPA Outbound Gateways always have access to the Spring Integration Message as input. As such the following parameters are available:

*parameter-source-factory*

An instance of `o.s.i.jpa.support.parametersource.ParameterSourceFactory` that will be used to get an instance of `o.s.i.jpa.support.parametersource.ParameterSource`. The *ParameterSource* is used to resolve the values of the parameters provided in the query. The *parameter-source-factory* attribute is ignored, if operations are performed using a JPA entity. If a *parameter* sub-element is used, the factory must be of type `ExpressionEvaluatingParameterSourceFactory`, located in package *o.s.i.jpa.support.parametersource*. *Optional*.

*use-payload-as-parameter-source*

If set to *true*, the payload of the Message will be used as a source for providing parameters. If set to *false*, the entire Message will be available as a source for parameters. If no JPA Parameters are passed in, this property will default to *true*. This means that using a default `BeanPropertyParameterSourceFactory`, the bean properties of the payload will be used as a source for parameter values for the to-be-executed JPA query. However, if JPA Parameters are passed in, then this property will by default evaluate to *false*. The reason is that JPA Parameters allow for SpEL Expressions to be provided and therefore it is highly beneficial to have access to the entire Message, including the Headers.

[[jpa-updating-outbound-gateway]]
=== Updating Outbound Gateway

[source,xml]
----
<int-jpa:updating-outbound-gateway request-channel="" TBD Section qName:co level:5, chunks:[] attrs:[id:outGateRequestChannel]
    auto-startup="true"
    entity-class=""
    entity-manager=""
    entity-manager-factory=""
    id=""
    jpa-operations=""
    jpa-query=""
    named-query=""
    native-query=""
    order=""
    parameter-source-factory=""
    persist-mode="MERGE"
    reply-channel="" TBD Section qName:co level:5, chunks:[] attrs:[id:outGateReplyChannel]
    reply-timeout="" TBD Section qName:co level:5, chunks:[] attrs:[id:outGateReplyTimeout]
    use-payload-as-parameter-source="true">

    <int:poller/>
    <int-jpa:transactional/>

    <int-jpa:parameter name="" type="" value=""/>
    <int-jpa:parameter name="" expression=""/>
</int-jpa:updating-outbound-gateway>
----

TBD Section qName:calloutlist level:4, chunks:[
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The channel from which the outbound gateway will receive messages for performing
						the desired operation. This attribute is similar to , Bold Section qName:emphasis level:7, chunks:[channel] attrs:[:],  attribute of the outbound-channel-adapter., Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outGateRequestChannel], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The channel to which the gateway will send the response after performing the required JPA operation.
						If this attribute is not defined, the request message must have a replyChannel header. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outGateReplyChannel], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						Specifies the time the gateway will wait to send the result to the reply channel.
						Only applies when the reply channel itself might block the send (for example a bounded QueueChannel that is currently full)., 
						By default the Gateway will wait indefinitely. The value is specified in milliseconds. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outGateReplyTimeout], 
			] attrs:[:][[jpa-retrieving-outbound-gateway]]
=== Retrieving Outbound Gateway

[source,xml]
----
<int-jpa:retrieving-outbound-gateway request-channel=""
    auto-startup="true"
    delete-after-poll="false"
    delete-in-batch="false"
    entity-class=""
    id-expression="" TBD Section qName:co level:5, chunks:[] attrs:[id:outGateIdExpression]
    entity-manager=""
    entity-manager-factory=""
    expect-single-result="false" TBD Section qName:co level:5, chunks:[] attrs:[id:outGateExpectSingleResult]
    id=""
    jpa-operations=""
    jpa-query=""
    max-number-of-results="" TBD Section qName:co level:5, chunks:[] attrs:[id:outGateMaxNumOfResults]
    max-results="" TBD Section qName:co level:5, chunks:[] attrs:[id:outGateMaxNumOfResults2]
    max-results-expression="" TBD Section qName:co level:5, chunks:[] attrs:[id:outGateMaxNumOfResultsExpression]
    first-result="" TBD Section qName:co level:5, chunks:[] attrs:[id:outGateFirstResult]
    first-result-expression="" TBD Section qName:co level:5, chunks:[] attrs:[id:outGateFirstResultExpression]
    named-query=""
    native-query=""
    order=""
    parameter-source-factory=""
    reply-channel=""
    reply-timeout=""
    use-payload-as-parameter-source="true">
    <int:poller></int:poller>
    <int-jpa:transactional/>

    <int-jpa:parameter name="" type="" value=""/>
    <int-jpa:parameter name="" expression=""/>
</int-jpa:retrieving-outbound-gateway>
----

TBD Section qName:calloutlist level:4, chunks:[
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						(Since , Bold Section qName:emphasis level:7, chunks:[Spring Integration 4.0] attrs:[:], ) The SpEL expression to determine the
						, Monospaced ([primaryKey]), 	value for
						, Monospaced ([EntityManager.find(Class entityClass, Object primaryKey)]),  method against
						the , Monospaced ([requestMessage]),  as root object of evaluation context.
						The , Monospaced ([entityClass]),  argument is determined from , Monospaced ([entity-class]),  attribute,
						if presented, otherwise from , Monospaced ([payload]),  class. All other attributed are disallowed
						in case of , Monospaced ([id-expression]), . , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outGateIdExpression], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						A boolean flag indicating whether the select operation is expected to return a single result or a , Monospaced ([List]),  of results.
						If this flag is set to , Monospaced ([true]), , the single entity selected is sent as the payload
						of the message. If multiple entities are returned, an exception is thrown., 
						If , Monospaced ([false]), , the , Monospaced ([List]),  of entities is being sent as the payload of the message.
						By default the value is , Monospaced ([false]), . , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outGateExpectSingleResult], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						, Bold Section qName:emphasis level:7, chunks:[Deprecated] attrs:[:], . Use , Monospaced ([max-results]),  instead.
						, Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outGateMaxNumOfResults], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						This non zero, non negative integer value tells the adapter not to select more than given number
						of rows on execution of the select operation. By default, if this attribute is not set,, 
						all the possible records are selected by given query. This attribute is mutually exclusive with
						, Monospaced ([max-results-expression]), . , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outGateMaxNumOfResults2], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						An expression, mutually exclusive with , Monospaced ([max-results]), , that can
						be used to provide an expression that will be evaluated to find the maximum number of results, 
						in a result set. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outGateMaxNumOfResultsExpression], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						This non zero, non negative integer value tells the adapter the first record from which the
						results are to be retrieved This attribute is mutually exclusive to , Monospaced ([first-result-expression]), .
						This attribute is introduced since version 3.0. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outGateFirstResult], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						This expression is evaluated against the message to find the position of first record in the
						result set to be retrieved This attribute is mutually exclusive to , Monospaced ([first-result]), .
						This attribute is introduced since version 3.0. , Bold Section qName:emphasis level:7, chunks:[Optional] attrs:[:], .
					], 
				] attrs:[arearefs:outGateFirstResultExpression], 
			] attrs:[:]IMPORTANT: When choosing to delete entities upon retrieval and you have retrieved a collection of entities, please be aware that by default entities are deleted on a per entity basis. This may cause performance issues.

 Alternatively, you can set attribute *deleteInBatch* to *true*, which will perform a batch delete. However, please be aware of the limitation that in that case cascading deletes are not supported.

 *JSR 317: Java Persistence 2.0* states in chapter Chapter 4.10, Bulk Update and Delete Operations that:

 "A delete operation only applies to entities of the specified class and its subclasses. It does not cascade to related entities."

 For more information please see http://jcp.org/en/jsr/detail?id=317[JSR 317: Java Persistence 2.0]

[[outboundGatewaySamples]]
=== JPA Outbound Gateway Samples

This section contains various examples of the *Updating Outbound Gateway* and *Retrieving Outbound Gateway*

*Update using an Entity Class*

In this example an *Updating Outbound Gateway* is persisted using solely the entity class `org.springframework.integration.jpa.test.entity.Student` as JPA defining parameter.

[source,xml]
----
<int-jpa:updating-outbound-gateway request-channel="entityRequestChannel" TBD Section qName:co level:5, chunks:[] attrs:[id:gatewayEntityReqChannel]
    reply-channel="entityResponseChannel" TBD Section qName:co level:5, chunks:[] attrs:[id:gatewayEntityRepChannel]
    entity-class="org.springframework.integration.jpa.test.entity.Student"
    entity-manager="em"/>
----

TBD Section qName:calloutlist level:4, chunks:[
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						This is the request channel for the outbound gateway,
						this is similar to the , Bold Section qName:emphasis level:7, chunks:[channel] attrs:[:], 
						attribute of the , Bold Section qName:emphasis level:7, chunks:[outbound-channel-adapter] attrs:[:], 
					], 
				] attrs:[arearefs:gatewayEntityReqChannel], 
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						This is where a gateway differs from an outbound adapter,
						this is the channel over which the reply of the performed, 
						JPA operation is received. If,however, you are not
						interested in the reply received and just want to perform, 
						the operation, then using a JPA , Bold Section qName:emphasis level:7, chunks:[outbound-channel-adapter] attrs:[:], 
						is the appropriate choice. In above case, where we are
						using entity class, the reply will be the entity object, 
						that was created/merged as a result of the JPA operation.
					], 
				] attrs:[arearefs:gatewayEntityRepChannel], 
			] attrs:[:]*Update using JPQL*

In this example, we will see how we can update an entity using the Java Persistence Query Language (JPQL). For this we use an *Updating Outbound Gateway*.

[source,xml]
----
<int-jpa:updating-outbound-gateway request-channel="jpaqlRequestChannel"
  reply-channel="jpaqlResponseChannel"
  jpa-query="update Student s set s.lastName = :lastName where s.rollNumber = :rollNumber" TBD Section qName:co level:5, chunks:[] attrs:[id:jpaQlGatewayQuery]
  entity-manager="em">
    <int-jpa:parameter name="lastName" expression="payload"/>
    <int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/>
</int-jpa:updating-outbound-gateway>
----

TBD Section qName:calloutlist level:4, chunks:[
				, TBD Section qName:callout level:5, chunks:[
					, Paragraph: chunks:[
						The JPQL query that will be executed by the gateway. Since
						an , Bold Section qName:emphasis level:7, chunks:[Updating Outbound Gateway] attrs:[:],  is used,
						only , Bold Section qName:emphasis level:7, chunks:[update] attrs:[:],  and , Bold Section qName:emphasis level:7, chunks:[delete] attrs:[:], 
						JPQL queries would be sensible choices.
					], 
				] attrs:[arearefs:jpaQlGatewayQuery], 
			] attrs:[:]When sending a message with a String payload and containing a header *rollNumber* with a *long* value, the last name of the student with the provided roll number is updated to the value provided in the message payload. When using an *UPDATING* gateway, the return value is *always* an integer value which denotes the number of records affected by execution of the JPA QL.

*Retrieving an Entity using JPQL*

The following examples uses a *Retrieving Outbound Gateway* together with JPQL to retrieve (select) one or more entities from the database.

[source,xml]
----
<int-jpa:retrieving-outbound-gateway request-channel="retrievingGatewayReqChannel"
    reply-channel="retrievingGatewayReplyChannel"
    jpa-query="select s from Student s where s.firstName = :firstName and s.lastName = :lastName"
    entity-manager="em">
    <int-jpa:parameter name="firstName" expression="payload"/>
    <int-jpa:parameter name="lastName" expression="headers['lastName']"/>
</int-jpa:outbound-gateway>
----

*Retrieving an Entity using id-expression*

The following examples uses a *Retrieving Outbound Gateway* together with `id-expression` to retrieve (find) one and only one entity from the database. The `primaryKey` is the result of `id-expression` evaluation. The `entityClass` is a class of Message `payload`.

[source,xml]
----
<int-jpa:retrieving-outbound-gateway
	request-channel="retrievingGatewayReqChannel"
    reply-channel="retrievingGatewayReplyChannel"
    id-expression="payload.id"
    entity-manager="em"/>
----

*Update using a Named Query*

Using a Named Query is basically the same as using a JPQL query directly. The difference is that the *named-query* attribute is used instead, as seen in the xml snippet below.

[source,xml]
----
<int-jpa:updating-outbound-gateway request-channel="namedQueryRequestChannel"
    reply-channel="namedQueryResponseChannel"
    named-query="updateStudentByRollNumber"
    entity-manager="em">
    <int-jpa:parameter name="lastName" expression="payload"/>
    <int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/>
</int-jpa:outbound-gateway>
----

NOTE: You can find a complete Sample application for using Spring Integration's JPA adapter at:

 https://github.com/SpringSource/spring-integration-samples/tree/master/basic/jpa[https://github.com/SpringSource/spring-integration-samples/tree/master/basic/jpa]

