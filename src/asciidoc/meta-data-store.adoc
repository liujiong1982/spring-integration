[[metadata-store]]
= Metadata Store

Many external systems, services or resources aren't transactional (Twitter, RSS, file system etc.) and there is no any ability to mark the data as read. Or there is just need to implement the Enterprise Integration Pattern http://eaipatterns.com/IdempotentReceiver.html[Idempotent Receiver] in some integration solutions. To achieve this goal and store some previous state of the Endpoint before the next interaction with external system, or deal with the next Message, Spring Integration provides the *Metadata Store* component being an implementation of the `org.springframework.integration.metadata.MetadataStore` interface with a general *key-value* contract.

The *Metadata Store* is designed to store various types of generic meta-data (e.g., published date of the last feed entry that has been processed) to help components such as the Feed adapter deal with duplicates. If a component is not directly provided with a reference to a `MetadataStore`, the algorithm for locating a metadata store is as follows: First, look for a bean with id `metadataStore` in the ApplicationContext. If one is found then it will be used, otherwise it will create a new instance of `SimpleMetadataStore` which is an in-memory implementation that will only persist metadata within the lifecycle of the currently running Application Context. This means that upon restart you may end up with duplicate entries.

If you need to persist metadata between Application Context restarts, two persistent `MetadataStores` are provided by the framework:

PropertiesPersistingMetadataStore

		
<<redis-metadata-store>>

		
<<gemfire-metadata-store>>

	

The `PropertiesPersistingMetadataStore` is backed by a properties file and a http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/PropertiesPersister.html[PropertiesPersister].

[source,xml]
----
<bean id="metadataStore"
    class="org.springframework.integration.store.PropertiesPersistingMetadataStore"/>
----

Alternatively, you can provide your own implementation of the `MetadataStore` interface (e.g. JdbcMetadataStore) and configure it as a bean in the Application Context.

Starting with *version 4.0*, `SimpleMetadataStore`, `PropertiesPersistingMetadataStore` and `RedisMetadataStore` implement `ConcurrentMetadataStore`. These provide for atomic updates and can be used across multiple component or application instances.

[[idempotent-receiver]]
== Idempotent Receiver

The *Metadata Store* is useful for implementing the EIP http://eaipatterns.com/IdempotentReceiver.html[Idempotent Receiver] pattern, when there is need to *filter* an incoming Message if it has already been processed, and just discard it or perform some other logic on discarding. The following configuration is an example of how to do this:

[source,xml]
----
<int:filter input-channel="serviceChannel"
			output-channel="idempotentServiceChannel"
			discard-channel="discardChannel"
			expression="@metadataStore.get(headers.businessKey) == null"/>

<int:publish-subscribe-channel id="idempotentServiceChannel"/>

<int:outbound-channel-adapter channel="idempotentServiceChannel"
                              expression="@metadataStore.put(headers.businessKey, '')"/>

<int:service-activator input-channel="idempotentServiceChannel" ref="service"/>
----

The `value` of the idempotent entry may be some expiration date, after which that entry should be removed from *Metadata Store* by some scheduled reaper.

