[[content-enricher]]
= Content Enricher

[[content-enricher-introduction]]
== Introduction

At times you may have a requirement to enhance a request with more information than was provided by the target system. The http://www.eaipatterns.com/DataEnricher.html[Content Enricher] pattern describes various scenarios as well as the component (Enricher), which allows you to address such requirements.

The Spring Integration `Core` module includes 2 enrichers:

<<header-enricher,Header Enricher>>

            
<<payload-enricher,Payload Enricher>>

        

Furthermore, several *Adapter specific Header Enrichers* are included as well:

<<xml-xpath-header-enricher,XPath Header Enricher (XML Module)>>

            
<<mail-namespace,Mail Header Enricher (Mail Module)>>

            
<<xmpp-message-outbound-channel-adapter,XMPP Header Enricher (XMPP Module)>>

        

Please go to the adapter specific sections of this reference manual to learn more about those adapters.

For more information regarding expressions support, please see <<spel>>.

[[header-enricher]]
== Header Enricher

If you only need to add headers to a Message, and they are not dynamically determined by the Message content, then referencing a custom implementation of a Transformer may be overkill. For that reason, Spring Integration provides support for the *Header Enricher* pattern. It is exposed via the `<header-enricher>` element.

[source,xml]
----
<int:header-enricher input-channel="in" output-channel="out">
     <int:header name="foo" value="123"/>
     <int:header name="bar" ref="someBean"/>
</int:header-enricher>
----

The *Header Enricher* also provides helpful sub-elements to set well-known header names.

[source,xml]
----
<int:header-enricher input-channel="in" output-channel="out">
		<int:error-channel ref="applicationErrorChannel"/>
		<int:reply-channel ref="quoteReplyChannel"/>
		<int:correlation-id value="123"/>
		<int:priority value="HIGHEST"/>
		<int:header name="bar" ref="someBean"/>
</int:header-enricher>
----

In the above configuration you can clearly see that for well-known headers such as `errorChannel`, `correlationId`, `priority`, `replyChannel`etc., instead of using generic *<header>* sub-elements where you would have to provide both header 'name' and 'value', you can use convenient sub-elements to set those values directly.

*POJO Support*

Often a header value cannot be defined statically and has to be determined dynamically based on some content in the Message. That is why *Header Enricher* allows you to also specify a bean reference using the `ref` and `method` attribute. The specified method will calculate the header value. Let's look at the following configuration:

[source,xml]
----
<int:header-enricher input-channel="in" output-channel="out">
    <int:header name="foo" method="computeValue" ref="myBean"/>
</int:header-enricher>

<bean id="myBean" class="foo.bar.MyBean"/>
----

[source,java]
----
public class MyBean {
    public String computeValue(String payload){
        return payload.toUpperCase() + "_US";
    }

}
----

You can also configure your POJO as inner bean:

[source,xml]
----
<int:header-enricher  input-channel="inputChannel" output-channel="outputChannel">
	<int:header name="some_header">
            <bean class="org.MyEnricher"/>
        </int:header>
</int:header-enricher>
----

as well as point to a Groovy script:

[source,xml]
----
<int:header-enricher  input-channel="inputChannel" output-channel="outputChannel">
		<int:header name="some_header">
            <int-groovy:script location="org/SampleGroovyHeaderEnricher.groovy"/>
        </int:header>
</int:header-enricher>
----

*SpEL Support*

In Spring Integration 2.0 we have introduced the convenience of the http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/expressions.html[Spring Expression Language (SpEL)] to help configure many different components. The *Header
	        Enricher* is one of them. Looking again at the POJO example above, you can see that the computation logic to determine the header value is actually pretty simple. A natural question would be: "is there a simpler way to accomplish this?". That is where SpEL shows its true power.

[source,xml]
----
<int:header-enricher input-channel="in" output-channel="out">
	<int:header name="foo" expression="payload.toUpperCase() + '_US'"/>
</int:header-enricher>
----

As you can see, by using SpEL for such simple cases, we no longer have to provide a separate class and configure it in the application context. All we need is the *expression* attribute configured with a valid SpEL expression. The 'payload' and 'headers' variables are bound to the SpEL Evaluation Context, giving you full access to the incoming Message.

[[header-channel-registry]]
=== Header Channel Registry

Starting with *Spring Integration 3.0*, a new sub-element `<int:header-channels-to-string/>` is available; it has no attributes. This converts existing `replyChannel` and `errorChannel` headers (when they are a `MessageChannel`) to a String and stores the channel(s) in a registry for later resolution when it is time to send a reply, or handle an error. This is useful for cases where the headers might be lost; for example when serializing a message into a message store or when transporting the message over JMS. If the header does not already exist, or it is not a `MessageChannel`, no changes are made.

Use of this functionality requires the presence of a `HeaderChannelRegistry` bean. By default, the framework creates a `DefaultHeaderChannelRegistry` with the default expiry (60 seconds). Channels are removed from the registry after this time. To change this, simply define a bean with id `integrationHeaderChannelRegistry` and configure the required default delay using a constructor argument (milliseconds).

Since *version 4.1*, you can set a property `removeOnGet` to `true` on the `<bean/>` definition, and the mapping entry will be removed immediately on first use. This might be useful in a high-volume environment and when the channel is only used once, rather than waiting for the reaper to remove it.

The `HeaderChannelRegistry` has a `size()` method to determine the current size of the registry. The `runReaper()` method cancels the current scheduled task and runs the reaper immediately; the task is then scheduled to run again based on the current delay. These methods can be invoked directly by getting a reference to the registry, or you can send a message with, for example, the following content to a control bus:

[source]
----
"@integrationHeaderChannelRegistry.runReaper()"
----

This sub-element is a convenience only, and is the equivalent of specifying:

[source,xml]
----
<int:reply-channel
	expression="@integrationHeaderChannelRegistry.channelToChannelName(headers.replyChannel)"
	overwrite="true" />
<int:error-channel
	expression="@integrationHeaderChannelRegistry.channelToChannelName(headers.errorChannel)"
	overwrite="true" />
----

Starting with *version 4.1*, you can now override the registry's configured reaper delay, so the the channel mapping is retained for at least the specified time, regardless of the reaper delay:

[source,xml]
----
<int:header-enricher input-channel="inputTtl" output-channel="next">
	<int:header-channels-to-string time-to-live-expression="120000" />
</int:header-enricher>

<int:header-enricher input-channel="inputCustomTtl" output-channel="next">
	<int:header-channels-to-string 
		time-to-live-expression="headers['channelTTL'] ?: 120000" />
</int:header-enricher>
----

In the first case, the time to live for every header channel mapping will be 2 minutes; in the second case, the time to live is specified in the message header and uses an elvis operator to use 2 minutes if there is no header.

[[payload-enricher]]
== Payload Enricher

In certain situations the Header Enricher, as discussed above, may not be sufficient and payloads themselves may have to be enriched with additional information. For example, order messages that enter the Spring Integration messaging system have to look up the order's customer based on the provided customer number and then enrich the original payload with that information.

Since Spring Integration 2.1, the Payload Enricher is provided. A Payload Enricher defines an endpoint that passes a `Message` to the exposed request channel and then expects a reply message. The reply message then becomes the root object for evaluation of expressions to enrich the target payload.

The Payload Enricher provides full XML namespace support via the `enricher` element. In order to send request messages, the payload enricher has a `request-channel` attribute that allows you to dispatch messages to a request channel.

Basically by defining the request channel, the Payload Enricher acts as a Gateway, waiting for the message that were sent to the request channel to return, and the Enricher then augments the message's payload with the data provided by the reply message.

When sending messages to the request channel you also have the option to only send a subset of the original payload using the `request-payload-expression` attribute.

The enriching of payloads is configured through SpEL expressions, providing users with a maximum degree of flexibility. Therefore, users are not only able to enrich payloads with direct values from the reply channel's `Message`, but they can use SpEL expressions to extract a subset from that Message, only, or to apply addtional inline transformations, allowing them to further manipulate the data.

If you only need to enrich payloads with static values, you don't have to provide the `request-channel` attribute.

NOTE: Enrichers are a variant of Transformers and in many cases you could use a Payload Enricher or a generic Transformer implementation to add additional data to your messages payloads. Thus, familiarize yourself with all transformation-capable components that are provided by Spring Integration and carefully select the implementation that semantically fits your business case best.

[[payload-enricher-configuration]]
=== Configuration

Below, please find an overview of all available configuration options that are available for the payload enricher:

[source,xml]
----
<int:enricher request-channel=""                          TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher01-co, linkends:payload-enricher01]
              auto-startup="true"                         TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher02-co, linkends:payload-enricher02]
              id=""                                       TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher03-co, linkends:payload-enricher03]
              order=""                                    TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher04-co, linkends:payload-enricher04]
              output-channel=""                           TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher05-co, linkends:payload-enricher05]
              request-payload-expression=""               TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher06-co, linkends:payload-enricher06]
              reply-channel=""                            TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher07-co, linkends:payload-enricher07]
              send-timeout=""                             TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher08-co, linkends:payload-enricher08]
              should-clone-payload="false">               TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher09-co, linkends:payload-enricher09]
    <int:poller></int:poller>                             TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher10-co, linkends:payload-enricher10]
    <int:property name="" expression="" null-result-expression="'Could not determine the name'"/>  TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher11-co, linkends:payload-enricher11]
    <int:property name="" value="23" type="java.lang.Integer" null-result-expression="'0'"/>
    <int:header name="" expression="" null-result-expression=""/>  TBD Section qName:co level:5, chunks:[] attrs:[id:payload-enricher12-co, linkends:payload-enricher12]
    <int:header name="" value="" overwrite="" type="" null-result-expression=""/>
</int:enricher>
----

TBD Section qName:calloutlist level:5, chunks:[
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
	                        Channel to which a Message will be sent to get the data to use for enrichment.
	                        , Bold Section qName:emphasis level:8, chunks:[Optional] attrs:[:], .
	                    ], 
	                ] attrs:[arearefs:payload-enricher01-co, id:payload-enricher01], 
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
	                        Lifecycle attribute signaling if this component should be
	                        started during Application Context startup. Defaults to true., 
	                        , Bold Section qName:emphasis level:8, chunks:[Optional] attrs:[:], .
	                    ], 
	                ] attrs:[arearefs:payload-enricher02-co, id:payload-enricher02], 
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
	                        Id of the underlying bean definition, which is either
	                        an , Monospaced ([EventDrivenConsumer]),  or a
	                        , Monospaced ([PollingConsumer]), .
	                        , Bold Section qName:emphasis level:8, chunks:[Optional] attrs:[:], .
	                    ], 
	                ] attrs:[arearefs:payload-enricher03-co, id:payload-enricher03], 
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
	                        Specifies the order for invocation when this endpoint is
	                        connected as a subscriber to a channel. This is particularly, 
	                        relevant when that channel is using a "failover" dispatching
	                        strategy. It has no effect when this endpoint itself is a, 
	                        Polling Consumer for a channel with a queue.
	                        , Bold Section qName:emphasis level:8, chunks:[Optional] attrs:[:], .
	                    ], 
	                ] attrs:[arearefs:payload-enricher04-co, id:payload-enricher04], 
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
	                        Identifies the Message channel where a Message will
	                        be sent after it is being processed by this endpoint., 
	                        , Bold Section qName:emphasis level:8, chunks:[Optional] attrs:[:], .
	                    ], 
	                ] attrs:[arearefs:payload-enricher05-co, id:payload-enricher05], 
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
	                        By default the original message's payload will be used as
	                        payload that will be send to the , Monospaced ([request-channel]), .
	                        By specifying a SpEL expression as value for the, 
	                        , Monospaced ([request-payload-expression]),  attribute, a
	                        subset of the original payload, a header value or any other, 
	                        resolvable SpEL expression can be used as the basis for the
	                        payload, that will be sent to the request-channel., 
	                    ], 
	                    , Paragraph: chunks:[
	                        For the Expression evaluation the full message is available
	                        as the 'root object'., 
	                    ], 
	                    , Paragraph: chunks:[
	                        For instance the following SpEL expressions (among others)
	                        are possible:, 
	                    ], 
	                    , ItemizedList Section qName:itemizedlist level:7, chunks:[
	                        , ListItem Section qName:listitem level:8, chunks:[payload.foo] attrs:[:], 
	                        , ListItem Section qName:listitem level:8, chunks:[headers.foobar] attrs:[:], 
	                        , ListItem Section qName:listitem level:8, chunks:[new java.util.Date()] attrs:[:], 
	                        , ListItem Section qName:listitem level:8, chunks:['foo' + 'bar'] attrs:[:], 
	                    ] attrs:[:], 
	                    , Paragraph: chunks:[
	                        If more sophisticated logic is required (e.g. changing the
	                        message headers etc.) please use additional downstream transformers., 
	                        , Bold Section qName:emphasis level:8, chunks:[Optional] attrs:[:], .
	                    ], 
	                ] attrs:[arearefs:payload-enricher06-co, id:payload-enricher06], 
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
	                        Channel where a reply Message is expected. This is optional; typically the auto-generated
	                        temporary reply channel is sufficient., 
	                        , Bold Section qName:emphasis level:8, chunks:[Optional] attrs:[:], .
	                    ], 
	                ] attrs:[arearefs:payload-enricher07-co, id:payload-enricher07], 
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
	                        Maximum amount of time in milliseconds to wait when
	                        sending a message to the channel, if such channel may block., 
	                    ], 
	                    , Paragraph: chunks:[
	                        For example, a Queue Channel can block until space is
	                        available, if its maximum capacity has been reached. Internally, 
	                        the send timeout is set on the , Monospaced ([MessagingTemplate]), 
	                        and ultimately applied when invoking the send operation on the
	                        , Monospaced ([MessageChannel]), .
	                    ], 
	                    , Paragraph: chunks:[
	                        By default the send timeout is set to '-1', which may cause
	                        the send operation on the , Monospaced ([MessageChannel]), ,
	                        depending on the implementation, to block indefinitely., 
	                        , Bold Section qName:emphasis level:8, chunks:[Optional] attrs:[:], .
	                    ], 
	                ] attrs:[arearefs:payload-enricher08-co, id:payload-enricher08], 
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
	                        Boolean value indicating whether any payload that implements
	                        , Monospaced ([Cloneable]),  should be cloned
	                        prior to sending the Message to the request chanenl for, 
	                        acquiring the enriching data. The cloned version would be
	                        used as the target payload for the ultimate reply., 
	                        Default is , Monospaced ([false]), .
	                        , Bold Section qName:emphasis level:8, chunks:[Optional] attrs:[:], .
	                    ], 
	                ] attrs:[arearefs:payload-enricher09-co, id:payload-enricher09], 
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
	                        Allows you to configure a Message Poller if this endpoint
	                        is a Polling Consumer., 
	                        , Bold Section qName:emphasis level:8, chunks:[Optional] attrs:[:], .
	                    ], 
	                ] attrs:[arearefs:payload-enricher10-co, id:payload-enricher10], 
	                , TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
                            Each , Monospaced ([property]),  sub-element provides the
                            name of a property (via the mandatory , Monospaced ([name]), 
                            attribute). That property should  be settable on the
                            target payload instance. Exactly one of the , Monospaced ([value]), 
                            or , Monospaced ([expression]),  attributes must be provided
                            as well. The former for a literal value to set, and the, 
                            latter for a SpEL expression to be evaluated. The root
                            object of the evaluation context is the Message that was, 
                            returned from the flow initiated by this enricher, the
                            input Message if there is no request channel, or the, 
                            application context (using the '@, <, beanName, >, ., <, beanProperty, >, '
                            SpEL syntax)., 
	                    ], 
	                    , Paragraph: chunks:[
							Starting with , Bold Section qName:emphasis level:8, chunks:[4.0] attrs:[:], , when specifying
							a , Monospaced ([value]),  attribute, you can also specify an optional
							, Monospaced ([type]),  attribute. When the destination is a
							typed setter method, the framework will coerce the value, 
							appropriately (as long as a , Monospaced ([PropertyEditor]), )
							exists to handle the conversion. If however, the target, 
							payload is a , Monospaced ([Map]),  the
							entry will be populated with the value without conversion. The, 
							, Monospaced ([type]),  attribute allows you to, say, convert
							a String containing a number to an , Monospaced ([Integer]), 
							value in the target payload.
	                    ], 
	                    , Paragraph: chunks:[
                            Starting with , Bold Section qName:emphasis level:8, chunks:[4.1] attrs:[:], , you can also specify an optional
                            , Monospaced ([null-result-expression]),  attribute. When the , Monospaced ([enricher]), 
                            returns null, it will be evaluated and the output of the evaluation will be returned instead.
	                    ], 
	                ] attrs:[arearefs:payload-enricher11-co, id:payload-enricher11], 
					, TBD Section qName:callout level:6, chunks:[
	                    , Paragraph: chunks:[
                            Each , Monospaced ([header]),  sub-element provides the
                            name of a Message header (via the mandatory , Monospaced ([name]), 
                            attribute). Exactly one of the , Monospaced ([value]), 
                            or , Monospaced ([expression]),  attributes must be provided
                            as well. The former for a literal value to set, and the, 
                            latter for a SpEL expression to be evaluated. The root
                            object of the evaluation context is the Message that was, 
                            returned from the flow initiated by this enricher, the
                            input Message if there is no request channel, or the, 
                            application context (using the '@, <, beanName, >, ., <, beanProperty, >, '
                            SpEL syntax)., 
                            Note, similar to the , Monospaced ([<, header-enricher, >]), , the , Monospaced ([<, enricher, >]), 's
                            , Monospaced ([header]),  element has , Monospaced ([type]),  and , Monospaced ([overwrite]),  attributes.
                            However, a difference is that, with the , Monospaced ([<, enricher, >]), ,
                            the , Monospaced ([overwrite]),  attribute is , Monospaced ([true]),  by default,
                            to be consistent with , Monospaced ([<, enricher, >]), 's
                            , Monospaced ([<, property, >]),  sub-element.
	                    ], 
	                    , Paragraph: chunks:[
                            Starting with , Bold Section qName:emphasis level:8, chunks:[4.1] attrs:[:], , you can also specify an optional
                            , Monospaced ([null-result-expression]),  attribute. When the , Monospaced ([enricher]), 
                            returns null, it will be evaluated and the output of the evaluation will be returned instead.
	                    ], 
	                ] attrs:[arearefs:payload-enricher12-co, id:payload-enricher12], 
	            ] attrs:[:]

[[payload-enricher-examples]]
=== Examples

Below, please find several examples of using a Payload Enricher in various situations.

In the following example, a `User` object is passed as the payload of the `Message`. The `User` has several properties but only the `username` is set initially. The Enricher's `request-channel` attribute below is configured to pass the `User` on to the `findUserServiceChannel`.

Through the implicitly set `reply-channel` a `User` object is returned and using the `property` sub-element, properties from the reply are extracted and used to enrich the original payload.

[source,xml]
----
<int:enricher id="findUserEnricher"
              input-channel="findUserEnricherChannel"
              request-channel="findUserServiceChannel">
    <int:property name="email"    expression="payload.email"/>
    <int:property name="password" expression="payload.password"/>
</int:enricher>
----

NOTE: The code samples shown here, are part of the *Spring
	            Integration Samples* project. Please feel free to check it out at: null

*How do I pass only a subset of data to the request channel?*

Using a `request-payload-expression` attribute a single property of the payload can be passed on to the request channel instead of the full message. In the example below on the username property is passed on to the request channel. Keep in mind, that alwhough only the username is passed on, the resulting message send to the request channel will contain the full set of `MessageHeaders`.

[source,xml]
----
<int:enricher id="findUserByUsernameEnricher"
              input-channel="findUserByUsernameEnricherChannel"
              request-channel="findUserByUsernameServiceChannel"
              request-payload-expression="payload.username">
    <int:property name="email"    expression="payload.email"/>
    <int:property name="password" expression="payload.password"/>
</int:enricher>
----

*How can I enrich payloads that consist of Collection data?*

In the following example, instead of a `User` object, a `Map` is passed in. The `Map` contains the username under the map key `username`. Only the `username` is passed on to the request channel. The reply contains a full `User` object, which is ultimately added to the `Map` under the `user` key.

[source,xml]
----
<int:enricher id="findUserWithMapEnricher"
              input-channel="findUserWithMapEnricherChannel"
              request-channel="findUserByUsernameServiceChannel"
              request-payload-expression="payload.username">
    <int:property name="user"    expression="payload"/>
</int:enricher>
----

*How can I enrich payloads with static information without using a request channel?*

Here is an example that does not use a request channel at all, but solely enriches the message's payload with static values. But please be aware that the word 'static' is used loosly here. You can still use SpEL expressions for setting those values.

[source,xml]
----
<int:enricher id="userEnricher"
              input-channel="input">
    <int:property name="user.updateDate" expression="new java.util.Date()"/>
    <int:property name="user.firstName" value="foo"/>
    <int:property name="user.lastName"  value="bar"/>
    <int:property name="user.age"       value="42"/>
</int:enricher>
----

